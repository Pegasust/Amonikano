using Discord;
using Amonikano.Library;
using static Amonikano.Library.custom_string_processor;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using System.Reflection;

namespace Amonikano
{
    /// <summary>
    /// All of these constants are supposed to be kept secret, but whatever, we don't need secret do we?
    /// </summary>
    public static class bot_const //TO HELL WITH NAMING PROBLEMS, I DON'T CARE
    {
        public const string client_id = "477149586851364867"; //I only all caps macros
        public const string client_secret = "QC6QmXIgHG1LwW9XrqVs5cvXln4PeRPQ";
        public const string token = "NDc3MTQ5NTg2ODUxMzY0ODY3.Dk4JiA.6I0tIiF7WUvG_24OEEhAck996cI";
        public const ulong dev_channel_id = 477182725447483410;
    }

    public static class bot_conf
    {
        #region command and user message distinguishment
        /// <summary>
        /// Set to true, and whether a command follows the syntax of a command or not, it would still be processed if mentioned.
        /// </summary>
        public const bool process_command_when_mentioned = true;
        /// <summary>
        /// Set to true and the bot will nullify all system messages generated by discord, or even itself
        /// </summary>
        public const bool nullify_system_message = true;

        public const bool check_prefix_determine_command = true;
        public const string str_command_prefix = "!";
        public const char char_command_prefix = '!';

        public const bool check_suffix_determine_command = false;
        public const string str_command_suffix = "«";
        public const char char_command_suffix = '«';

        public static bool is_command(Discord.WebSocket.SocketMessage msg)
        {
            //If msg is null, ignore it
            if (nullify_system_message)
            {
                Discord.WebSocket.SocketUserMessage user_msg = msg as Discord.WebSocket.SocketUserMessage;
                if (user_msg == null)
                    return false;
            }
            else
            {
                if (msg == null)
                    return false;
            }

            //set up processor (sorry if it's getting less and less readable)
            #region processor
            Dictionary<lookup_type, char[]> char_lookup = new Dictionary<lookup_type, char[]>();
            if (check_prefix_determine_command)
            {
                char_lookup[lookup_type.prefix] = new char[1] { char_command_prefix };
            }
            if (check_suffix_determine_command)
            {
                char_lookup[lookup_type.suffix] = new char[1] { char_command_suffix };
            }
            string content = msg.Content;
            custom_string_processor processor = new custom_string_processor(char_lookup, null, true);
            #endregion

            return processor.string_satisfied(content);
        }

        public const string startup_message = "Configs: \n " + (process_command_when_mentioned ? "+ process command if mentioned\n" : "")
            + (nullify_system_message ? "+ nullify system messages\n" : "")
            + (check_prefix_determine_command ? "+ command needs prefix: " + str_command_prefix + "\n" : "")
            + (check_suffix_determine_command ? "+ command needs suffix: " + str_command_suffix + "\n" : "")
            ;

        #endregion
        /// <summary>
        /// Socket configuration of a client
        /// </summary>
        public static Discord.WebSocket.DiscordSocketConfig socket_config = new Discord.WebSocket.DiscordSocketConfig
        {
            MessageCacheSize = 100, //Number of message per channel getting , idk?
            
        };
    }




    class Program
    {
        bool is_startup = true;               
        Discord.WebSocket.DiscordSocketClient client;
        Discord.WebSocket.ISocketMessageChannel main_dev_channel;
        
        private async Task start()
        {
            main_dev_channel = (Discord.WebSocket.ISocketMessageChannel) client.GetChannel(bot_const.dev_channel_id);
            await main_dev_channel.SendMessageAsync(bot_conf.startup_message);

        }

        static void Main(string[] args)
            => //This symbol is a lambda expression, search it up if you have to
            new Program().MainAsync(args).GetAwaiter().GetResult();


        /**
         * Basically, this calls an asynchronous main loop.
         * Because we assume the program run so fast that it runs asynchronously, there's nothing wrong with this.
        */
        /**
         * From here, I'll try to make the code looks neat and explanatory :)
         * */
        public async Task MainAsync(string[] args)
        {            
            //This is from another namespace. I don't intend to include a using namespace because it would look messy on the long run

            client = new Discord.WebSocket.
                DiscordSocketClient(bot_conf.socket_config);

            client.Log += on_client_log; //client.Log is like a delegate function (a list of function, or an event)
            client.MessageReceived += on_message_received;
            await client.LoginAsync(TokenType.Bot, bot_const.token);

            await client.StartAsync();
            
            await Task.Delay(-1);
            client.Connected += start;
            /*if (is_startup)
            {
                await start();
                is_startup = false;
            }*/
        }


        /// <summary>
        /// Gets called whenever the client logs something
        /// This basically logs out on the bot console (not in discord, but prolly on my computer)
        /// </summary>
        /// <param name="msg"></param>
        /// <returns></returns>
        private Task on_client_log(LogMessage msg) //not async because idk
        {
            Console.WriteLine(msg.ToString());
            return Task.CompletedTask;
        }

        /// <summary>
        /// Gets called whenever the client receives a message from discord
        /// </summary>
        /// <param name="msg"></param>
        /// <returns></returns>
        private async Task on_message_received(Discord.WebSocket.SocketMessage msg)
        {
            //TODO: make this work
            if (msg.MentionedUsers == client.CurrentUser)
            {
                await msg.Channel.SendMessageAsync("You mentioned me?");
            }
#if DEBUG
            else
            {
                Console.WriteLine("Mentioned user: "+msg.MentionedUsers);
                Console.WriteLine("Me: " + client.CurrentUser);
            }

#endif
#if DEBUG
            if (msg.Content == "!ping")
            {
                string output = "";
                DateTimeOffset created = msg.CreatedAt;
                DateTimeOffset msg_out = msg.Timestamp;
                TimeSpan delta = created - msg_out;
                Discord.WebSocket.SocketUser author = msg.Author;

                output = "The message, was created at " + created.ToString()
                    + " and was out at " + msg_out.ToString()
                    + " which took " + delta.Milliseconds + "ms."
                    + " Author is "+ author.ToString();
                await msg.Channel.SendMessageAsync("pong;below is message automatically generated by library\n"+ output);
            }

            System.DateTime benchmark_start = DateTime.Now;
#endif
            if (bot_conf.is_command(msg))
            {
                string output = "gratz, it's a command alright?";
#if DEBUG
                System.DateTime benchmark_end = DateTime.Now;
                TimeSpan delta = benchmark_end - benchmark_start;
                output += " "+ delta.TotalMilliseconds.ToString()+ "ms took to complete algorithm.";
#endif
                await msg.Channel.SendMessageAsync(output);
            }
        }
    }
}
