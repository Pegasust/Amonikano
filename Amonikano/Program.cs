using Discord;
using Amonikano.Library;
using static Amonikano.Library.custom_string_processor;
using static Amonikano.Library.Helper;
using System;
using System.Collections.Generic; //Why collections when you can use array for more quality codes?
using System.Linq; //I hate Linq :(
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using System.Reflection;

namespace Amonikano
{
    /// <summary>
    /// All of these constants are supposed to be kept secret, but whatever, we don't need secret do we?
    /// </summary>
    public static class bot_const
    {
        /// <summary>
        /// Gotten from website. Probably unique per application
        /// </summary>
        public const string client_id = "477149586851364867";
        public const string client_mention_id = "<@" + client_id + ">";
        
        /// <summary>
        /// Gotton from website. Probably unique per application
        /// </summary>
        public const string client_secret = "QC6QmXIgHG1LwW9XrqVs5cvXln4PeRPQ";
        /// <summary>
        /// Gotten from website. Impartant shit, grant 100% access to application
        /// </summary>
        public const string token = "NDc3MTQ5NTg2ODUxMzY0ODY3.Dk4JiA.6I0tIiF7WUvG_24OEEhAck996cI";
        /// <summary>
        /// devv/bot-test id
        /// </summary>
        public const ulong dev_channel_id = 477182725447483410;
    }

    public static class bot_conf
    {
#if COMPLETE
        #region command and user message distinguishment
        /// <summary>
        /// Set to true, and whether a command follows the syntax of a command or not, it would still be processed if mentioned.
        /// </summary>
        public const bool process_command_when_mentioned = true;
        /// <summary>
        /// Set to true and the bot will nullify all system messages generated by discord, or even itself
        /// </summary>
        public const bool nullify_system_message = true;

        public const bool check_prefix_determine_command = true;
        public const string str_command_prefix = "!";
        public const char char_command_prefix = '!';

        public const bool check_suffix_determine_command = false;
        public const string str_command_suffix = "«";
        public const char char_command_suffix = '«';

        public static bool is_command(Discord.WebSocket.SocketMessage msg)
        {
            //If msg is null, ignore it
            if (nullify_system_message)
            {
                Discord.WebSocket.SocketUserMessage user_msg = msg as Discord.WebSocket.SocketUserMessage;
                if (user_msg == null)
                    return false;
            }
            else
            {
                if (msg == null)
                    return false;
            }

            //set up processor (sorry if it's getting less and less readable)
        #region processor
            Dictionary<lookup_type, char[]> char_lookup = new Dictionary<lookup_type, char[]>();
            if (check_prefix_determine_command)
            {
                char_lookup[lookup_type.prefix] = new char[1] { char_command_prefix };
            }
            if (check_suffix_determine_command)
            {
                char_lookup[lookup_type.suffix] = new char[1] { char_command_suffix };
            }
            string content = msg.Content;
            custom_string_processor processor = new custom_string_processor(char_lookup, null, true);
        #endregion

            return processor.string_satisfied(content);
        }

        public const string startup_message = "Configs: \n " + (process_command_when_mentioned ? "+ process command if mentioned\n" : "")
            + (nullify_system_message ? "+ nullify system messages\n" : "")
            + (check_prefix_determine_command ? "+ command needs prefix: " + str_command_prefix + "\n" : "")
            + (check_suffix_determine_command ? "+ command needs suffix: " + str_command_suffix + "\n" : "")
            ;

        #endregion
        /// <summary>
        /// Socket configuration of a client
        /// </summary>
        public static Discord.WebSocket.DiscordSocketConfig socket_config = new Discord.WebSocket.DiscordSocketConfig
        {
            MessageCacheSize = 100, //Number of message per channel getting , idk?
            
        };
#else
        public const char char_prefix = '}';
        public const string str_prefix = "}";
        public static Discord.WebSocket.DiscordSocketConfig socket_config = new Discord.WebSocket.DiscordSocketConfig
        {
            MessageCacheSize = 100,

        };
        public const string startup_message = "";
        public static bool is_command(Discord.WebSocket.SocketMessage msg)
        {
            string msg_content = msg.Content;
            msg_content = msg_content.Trim();
            return msg_content[0] == char_prefix;
        }
        public static bool is_command(Discord.WebSocket.SocketMessage msg, out string new_string)
        {
            string msg_content = msg.Content;
            msg_content = msg_content.Trim();
            if (msg_content[0] == char_prefix)
            {
                new_string = msg_content.Substring(1);
                return true;
            }
            else
            {
                new_string = null;
                return false;
            }
        }
        public static bool is_command(string trimmed_msg)
        {
            return trimmed_msg[0] == char_prefix;
        }
        public static bool is_command(string trimmed_msg, out string new_string)
        {
            if (trimmed_msg[0] == char_prefix)
            {
                new_string = trimmed_msg.Substring(1);
                return true;
            }
            else
            {
                new_string = null;
                return false;
            }
        }
        public static bool is_command_raw(string untrimmed_msg)
        {
            untrimmed_msg = untrimmed_msg.Trim();
            return untrimmed_msg[0] == char_prefix;
        }
        public static bool is_command_raw(string untrimmed_msg, out string new_msg)
        {
            untrimmed_msg = untrimmed_msg.Trim();
            if (untrimmed_msg[0] == char_prefix)
            {
                new_msg = untrimmed_msg.Substring(1);
                return true;
            }
            else
            {
                new_msg = null;
                return false;
            }
        }

#endif

    }




    class Program
    {
        bool is_startup = true;               
        Discord.WebSocket.DiscordSocketClient client;
        Discord.WebSocket.ISocketMessageChannel main_dev_channel;
        public static Discord.Commands.CommandService command_serv;
        IServiceProvider service;

        private async Task start()
        {
            main_dev_channel = (Discord.WebSocket.ISocketMessageChannel) client.GetChannel(bot_const.dev_channel_id);
            await main_dev_channel.SendMessageAsync(bot_conf.startup_message);
        }

        static void Main(string[] args)
            => //This symbol is a lambda expression, search it up if you have to
            new Program().MainAsync(args).GetAwaiter().GetResult();


        /**
         * Basically, this calls an asynchronous main loop.
         * Because we assume the program run so fast that it runs asynchronously, there's nothing wrong with this.
        */
        /**
         * From here, I'll try to make the code looks neat and explanatory :)
         * */
        public async Task MainAsync(string[] args)
        {            
            //This is from another namespace. I don't intend to include a using namespace because it would look messy on the long run

            client = new Discord.WebSocket.
                DiscordSocketClient(bot_conf.socket_config);

            command_serv = new Discord.Commands.CommandService();
            

            service = new ServiceCollection().BuildServiceProvider();
            client.Log += on_client_log; //client.Log is like a delegate function (a list of function, or an event)
            client.MessageReceived += on_message_received;

            await load_commands();

            await client.LoginAsync(TokenType.Bot, bot_const.token);

            await client.StartAsync();
            
            await Task.Delay(-1);
            //client.Connected += start;
            /*if (is_startup)
            {
                await start();
                is_startup = false;
            }*/
        }


        /// <summary>
        /// Gets called whenever the client logs something
        /// This basically logs out on the bot console (not in discord, but prolly on my computer)
        /// </summary>
        /// <param name="msg"></param>
        /// <returns></returns>
        private Task on_client_log(LogMessage msg) //not async because idk
        {
            Console.WriteLine(msg.ToString());
            return Task.CompletedTask;
        }

        private async Task load_commands()
        {
            await command_serv.AddModulesAsync(Assembly.GetEntryAssembly());
        }

        /// <summary>
        /// Gets called whenever the client receives a message from discord
        /// </summary>
        /// <param name="msg"></param>
        /// <returns></returns>
        private async Task on_message_received(Discord.WebSocket.SocketMessage msg)
        {
            string potential_command;
            bool is_command_by_mentioned = false;
            //TODO: make this work
            Console.WriteLine("=============== New Message ===============");
            string content = msg.Content;
            Discord.WebSocket.SocketUserMessage user_msg = msg as Discord.WebSocket.SocketUserMessage;
            Console.WriteLine("Content: " + content);
            Console.WriteLine("Is user message: " + (user_msg != null ? "true" : "false"));
            if (msg.Author.IsBot)
            {
                Console.WriteLine("Message is generated by a bot");
            }
            if (same_user(msg.Author, client.CurrentUser))
            {
                Console.WriteLine("Message generated by myself, aborting processing");
                return;
            }

            if (msg_mentioned_user(client.CurrentUser, user_msg,out potential_command))
            {
#if DEBUG
                await msg.Channel.SendMessageAsync("You mentioned me?");
#endif
                is_command_by_mentioned = true;
            }
            else
            {
                Console.WriteLine("Too bad, not mentioned :(.");
            }
#if DEBUG
            if (msg.Content == "!ping")
            {
                string output = "";
                DateTimeOffset created = msg.CreatedAt;
                DateTimeOffset msg_out = msg.Timestamp;
                TimeSpan delta = created - msg_out;
                Discord.WebSocket.SocketUser author = msg.Author;

                output = "The message, was created at " + created.ToString()
                    + " and was out at " + msg_out.ToString()
                    + " which took " + delta.Milliseconds + "ms."
                    + " Author is "+ author.ToString();
                await msg.Channel.SendMessageAsync("pong;below is message automatically generated by library\n"+ output);
            }

            System.DateTime benchmark_start = DateTime.Now;
#endif
            if (is_command_by_mentioned || bot_conf.is_command_raw(content, out potential_command))
            {
                string output = "Detected input command of "+potential_command+".";
#if DEBUG
                System.DateTime benchmark_end = DateTime.Now;
                TimeSpan delta = benchmark_end - benchmark_start;
                output += " "+ delta.TotalMilliseconds.ToString()+ "ms took to complete command detection algorithm.";
#endif
                await msg.Channel.SendMessageAsync(output);

#if DEBUG
                DateTime start = DateTime.Now;
#endif
                //command
                Discord.Commands.CommandContext context = new Discord.Commands.CommandContext(client, user_msg);
                var result = await command_serv.ExecuteAsync(context, potential_command, service);
                if (!result.IsSuccess)
                {
                    await context.Channel.SendMessageAsync(result.ErrorReason);
                }
#if DEBUG
                DateTime end = DateTime.Now;
                TimeSpan delta_time = end - start;
                await msg.Channel.SendMessageAsync("It took additionally " + delta_time.TotalMilliseconds.ToString() + " ms to execute command");
                
#endif
            }
        }
    }
}
